import React from "react";
import {useState} from "react";

import blue_str_bottom from '../pictures/blue_str_bottom.png'
import blue_str_left from '../pictures/blue_str_left.png'


import logoPDF from '../pictures/logo-pdf.png'
import pdfMake from "pdfmake/build/pdfmake"
import pdfFonts from "pdfmake/build/vfs_fonts"

pdfMake.vfs = pdfFonts.pdfMake.vfs;
function PG_Analysis({result}) {



    const [showDocumentationPG, setShowDocumentationPG] = useState(false);
    const [PG_result, setPG_result] = useState(null);
    const [PG_File_S, setPG_File] = useState(false);
    const [PG_Mapping_S, setPG_Mapping] = useState(false);
    const [PG_Section_S, setPG_Section] = useState(false);
    const [PG_SetInf_S, setPG_SetInf] = useState(false);
    const [PG_Process_S, setPG_Process] = useState(false);
    const [PG_Thread_S, setPG_Thread] = useState(false);
  
    const [Analysis_PG_S, setAnalysis_PG_S] = useState(false);


    function printPDF()
    {
   
      var docDefinition = {

        pageSize: "A4",
 
        content: [
          {
            margin: [0, 5, 0, 50],
            text: 'Прототип системы поведенческого анализа ВПО',
            style: 'header',
            alignment: 'center',
            fontSize: 24
          },
          {
            margin: [0, 5, 0, 100],
            text: 'Отчет по результатам исследования идентификации метода обхода АВЗ "Process Ghosting"',
            style: 'header',
            alignment: 'center',
            fontSize: 18
          },
          {
            margin: [0, 5, 0, 100],
            text: `Результат исследования: ${Analysis_PG_S}`,
            style: 'header',
            alignment: 'center',
            fontSize: 18
          },
         
          {
            style: 'tableExample',
            table: {
              widths: [120, 'auto'],
             
              body: [
                [{text: 'API вызов', style: 'tableHeader', alignment: 'center'}, {text: 'Значение', style: 'tableHeader', alignment: 'center'}],
                [{text: 'CreateFile', style: 'tableHeader', alignment: 'center'}, `${PG_File_S}`],
                [{text: 'CreateFileMapping', style: 'tableHeader', alignment: 'center'}, `${PG_Mapping_S}`],
                [{text: 'CreateSection', style: 'tableHeader', alignment: 'center'}, `${PG_Section_S}`],
                [{text: 'SetInformationFile', style: 'tableHeader', alignment: 'center'}, `${PG_SetInf_S}`],
                [{text: 'CreateProcess', style: 'tableHeader', alignment: 'center'}, `${PG_Process_S}`],
                [{text: 'CreateThread', style: 'tableHeader', alignment: 'center'}, `${PG_Thread_S}`],
              ]
            }
          },
          
        ],
          
        

        };
        pdfMake.createPdf(docDefinition).download();
    }

    const FshowDocumentationPG = () => {
        setShowDocumentationPG(!showDocumentationPG);
        //  console.log(result);
        return;
      }
    

    const PG_File = () => {
        if (!result) {
        //   setCli_inf(`Client: Получите результат анализа!`)
        //   cli_array.push(`Client: Получите результат анализа!`);
        //   setShowCLI(true);
          return;
        }
        const PG_File_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!CreateFileW\\n    arg 0: \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");
        //const PG_File_regx="~~\\d{1,}~~ \\w{1,}.\\w{1,}!CreateFileW\\n    arg 0: \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n";
        const PG_File_found = result.match(PG_File_regx);
        //const PG_File_split = PG_File_found[1].split('~');
        setPG_result(PG_File_found);
        setPG_File(PG_File_found);
        console.log(PG_File_found);
        return;
      }
    
    
      const PG_Mapping = () => {
        if (!result) {
        //   setCli_inf(`Client: Получите результат анализа!`)
        //   cli_array.push(`Client: Получите результат анализа!`);
        //   setShowCLI(true);
          return;
        }
        const PG_File_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!CreateFileMapping\\S{1,}\\n    arg 0: \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");
        //const PG_File_regx="~~\\d{1,}~~ \\w{1,}.\\w{1,}!CreateFileW\\n    arg 0: \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n";
        const PG_File_found = result.match(PG_File_regx);
        setPG_result(PG_File_found);
        setPG_Mapping(PG_File_found);
        console.log(PG_File_found);
        return;
      }
    
    
      const PG_Section = () => {
        if (!result) {
        //   setCli_inf(`Client: Получите результат анализа!`)
        //   cli_array.push(`Client: Получите результат анализа!`);
        //   setShowCLI(true);
          return;
        }
        const PG_Section_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!\\S{0,}CreateSection\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");

        const PG_Section_found = result.match(PG_Section_regx);
        const join = PG_Section_found.join('==');
    
        const includes = join.includes("1000000")
        if(includes==true)
        {
          setPG_result(PG_Section_found);
          setPG_Section(PG_Section_found);
          return;
        }
        setPG_result(null);
        setPG_Section(null);
      
        return;
      }
    
      const PG_SetInf = () => {
        if (!result) {
        //   setCli_inf(`Client: Получите результат анализа!`)
        //   cli_array.push(`Client: Получите результат анализа!`);
        //   setShowCLI(true);
          return;
        }
        const PG_Section_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!\\S{0,}SetInformationFile\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");
        const PG_Section_found = result.match(PG_Section_regx);
        const join = PG_Section_found.join('==');
        
        const includes = join.includes("arg 4: 0x000000000000000d")
        console.log("includes", join);
        if(includes==true)
        {
          setPG_result(PG_Section_found);
          setPG_SetInf(PG_Section_found);
          return;
        }
        setPG_result(null);
        setPG_SetInf(null);
       
        return;
      }
    
    
      const PG_Process = () => {
        if (!result) {
        //   setCli_inf(`Client: Получите результат анализа!`)
        //   cli_array.push(`Client: Получите результат анализа!`);
        //   setShowCLI(true);
          return;
        }
        const PG_Process_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!ZwCreateProcessEx\\n    arg 0: \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");
        // const PG_CreateEnvironmentBlock_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!CreateEnvironmentBlock\\n    arg 0: \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");
        const PG_WriteVirtualMemory_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!ZwWriteVirtualMemory\\n    arg 0: \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");
        //  const PG_Process_regx="~~\\d{1,}~~ \\w{1,}.\\w{1,}!ZwCreateProcessEx";
        const PG_Process_found = result.match(PG_Process_regx);
        // const PG_CreateEnvironmentBlock_found = result.match(PG_CreateEnvironmentBlock_regx);
        const PG_WriteVirtualMemory_found = result.match(PG_WriteVirtualMemory_regx);
        // console.log([...PG_Process_found, ...PG_WriteVirtualMemory_found]);
        setPG_result([...PG_Process_found, ...PG_WriteVirtualMemory_found]);
        setPG_Process([...PG_Process_found, ...PG_WriteVirtualMemory_found]);
        console.log(PG_Process_found);
        return;
      }
    
    
      const PG_Thread = () => {
        if (!result) {
        //   setCli_inf(`Client: Получите результат анализа!`)
        //   cli_array.push(`Client: Получите результат анализа!`);
        //   setShowCLI(true);
          return;
        }
        const PG_Thread_regx = new RegExp("~~\\d{1,}~~ \\w{1,}.\\w{1,}!ZwCreateThreadEx\\n    arg 0: \\S{1,}\\n    \\S{1,} \\S{1,} \\S{1,}\\n", "gmi");
    
        //  const PG_Thread_regx="~~\\d{1,}~~ \\w{1,}.\\w{1,}!ZwCreateThreadEx";
        const PG_Thread_found = result.match(PG_Thread_regx);
        setPG_result(PG_Thread_found);
        setPG_Thread(PG_Thread_found);
        console.log(PG_Thread_found);
        return;
      }
    


    const Analysis_PG = async () => {
        if (!result) {
            // setCli_inf(`Client: Получите результат анализа!`)
            // cli_array.push(`Client: Получите результат анализа!`);
            // setShowCLI(true);
            return;
        }
        setPG_File(false);
        setPG_SetInf(false);
        setPG_Section(false);
        setPG_Mapping(false);
        setPG_Process(false);
        setPG_Thread(false);
        setAnalysis_PG_S(false);
        // setCli_inf(`Client: Запущен анализ призрачного процесса`)
        // cli_array.push(`Client: Запущен анализ призрачного процесса`);

        setTimeout(PG_File, 1000);
        setTimeout(PG_SetInf, 2000);
        setTimeout(PG_Section, 3000);
        setTimeout(PG_Mapping, 5000);
        setTimeout(PG_Process, 7000);
        setTimeout(PG_Thread, 8000);
        // setCli_inf(`Client: Анализ призрачного процесса завершен`)
        // cli_array.push(`Client: Анализ призрачного процесса завершен`);


        return;
    }

    const out_result_analysis_PG = () => {
        if(!result){
        setAnalysis_PG_S("Результаты анализа отсутствуют, выполните анализ")
          return;
        }
        if(!PG_File_S){
          setAnalysis_PG_S("Файл не выполняет метод сокрытия процесса, нарушена цепочка API, соответствующая \"Process Ghosting\" (CreateFileW - нагрузка не создана)")
          return;
        }
        if(!PG_SetInf_S){
          setAnalysis_PG_S("Файл не выполняет метод сокрытия процесса, нарушена цепочка API, соответствующая \"Process Ghosting\" (SetInformationFile - файл не перешел в состояние \"ожидания удаления\")")
          return;
        }
        if(!PG_Section_S){
          setAnalysis_PG_S("Файл не выполняет метод сокрытия процесса, нарушена цепочка API, соответствующая \"Process Ghosting\" (CreateSection - секция не создана)")
          return;
        }
        if(!PG_Mapping_S){
          setAnalysis_PG_S("Файл не выполняет метод сокрытия процесса, нарушена цепочка API, соответствующая \"Process Ghosting\" (CreateFileMapping - раздел изображения не создан)")
          return;
        }
        if(!PG_Process_S){
          setAnalysis_PG_S("Файл не выполняет метод сокрытия процесса, нарушена цепочка API, соответствующая \"Process Ghosting\" (CreateProcessEx - процесс не создан)")
          return;
        }
        if(!PG_Thread_S){
          setAnalysis_PG_S("Файл не выполняет метод сокрытия процесса, нарушена цепочка API, соответствующая \"Process Ghosting\" (CreateThreadEx - поток не создан)")
          return;
        }
          setAnalysis_PG_S("Анализируемый файл выполняет метод сокрытия процесса, выполнена цепочка API, соответствующая \"Process Ghosting\"")
          return;
      }

    return (
        
            <div id='PG_Analysis' className="main-3">
                <a id='button-3' className="btn third" href='#main-2'>назад</a>
                <div className='config-result'>
                    <div className="zagl">
                        <div className='state_vpo'>
                            <button id='start_vpo_button' onClick={Analysis_PG} className="btn third"> Начать анализ Сокрытия процесса "Process Ghosting" </button>
                            <div className='state_vpo_main'>
                                <div className='state_vpo_left'>
                                    <button id={!PG_File_S ? 'state_vpo_button_notfound' : 'state_vpo_button_found'} onClick={PG_File} className="btn third">FILE</button>
                                    <img src={blue_str_bottom}></img>
                                    <button id={!PG_SetInf_S ? 'state_vpo_button_notfound' : 'state_vpo_button_found'} onClick={PG_SetInf} className="btn third">Set_INF</button>
                                    <img src={blue_str_bottom}></img>
                                    <button id={!PG_Section_S ? 'state_vpo_button_notfound' : 'state_vpo_button_found'} onClick={PG_Section} className="btn third">SECTION</button>
                                    <img src={blue_str_bottom}></img>
                                    <button id={!PG_Mapping_S ? 'state_vpo_button_notfound' : 'state_vpo_button_found'} onClick={PG_Mapping} className="btn third">MAPPING</button>
                                    <img src={blue_str_bottom}></img>
                                    <div className='state_vpo_middle'>
                                        <button id={!PG_Process_S ? 'state_vpo_button_notfound' : 'state_vpo_button_found'} onClick={PG_Process} className="btn third">PROCESS</button>

                                        <img id='blue_str_left' src={blue_str_left}></img>
                                        <button id={!PG_Thread_S ? 'state_vpo_button_notfound' : 'state_vpo_button_found'} onClick={PG_Thread} className="btn third">THREAD</button>
                                    </div>
                                </div>

                                <div className='state_vpo_right'>
                                    {!PG_result && <div className='item-api'><h3>Данный API вызов не обнаружен</h3></div>}
                                    {PG_result && PG_result.map((item) => <div className='item-api' key={item.id}>
                                        <p>{item}</p></div>)}
                                </div>
                            </div>
                        </div>
                        <div className='result_all' >
                            <div className='result_all_left'>
                                <div className='result_all_left_string'><div className='green'></div> <p>- API вызов обнаружен</p></div>
                                <div className='result_all_left_string'><div className='blue'></div><p>- API вызов не обнаружен</p></div>
                            </div>
                            <div onClick={out_result_analysis_PG} className='result_all_right'>
                                <button className='result_button'>Результат анализа:</button> {Analysis_PG_S && (<h3>{Analysis_PG_S}</h3>)}
                                {/* <p>Иcполняемый файл: {selectedFile.name} относится к бестелесным вирусам, обнаружена цепочка API вызовов, реализующая призрачный процесс</p> */}
                            </div>
                        </div>
                    </div>

                    <div className='window_result_text'>
                        <button onClick={FshowDocumentationPG} className="btn third" >Отобразить документацию</button>
                        {showDocumentationPG && <div className='result_text_PG'> <p>СОКРЫТИЕ ПРОЦЕССА</p>
                            <ol>
                                <li>Файл создан CreateFileW(Path). Получен дескриптор исполняемого файла для запуска.</li>
                                <li>Файл помещен в состояние ожидания удаления с помощью SetInformationFile (FileDispositionInformation). Использование свойства файла arg 1: FILE_DISPOSITION_ON_CLOSE флаг 0x00000008 не приведет к удалению файла.</li>
                                <li>Создан раздел «изображение/SEC_IMAGE» для файла CreateSection(File - дескриптор файла, AllocationAttributes (SEC_IMAGE)). Раздел отображает файл или часть файла в память. Раздел изображения — это специальный тип раздела, который соответствует файлам Portable Executable (PE) и может быть создан только из файлов PE (EXE, DLL и т. д.).</li>
                                <li>Создан/открыт именованный или безымянный объект сопоставления файлов для указанного файла CreateFileMapping[Numa]A (arg 5: SEC_IMAGE флаг 0x1000000).  NUMA используется для физической памяти.</li>
                                <li>Создан процесс, используя раздел изображения CreateProcessEx(Section)</li>
                                <li>Назначены аргументы процесса и переменные среды CreateEnvironmentBlock/WriteVirtualMemory</li>
                                <li>Создан поток для выполнения в процессе CreateThreadEx</li>
                            </ol> </div>}
                    </div>
                </div>
                <div className='to_main-3'>
                  <button id="btn-create-pdf" className="btn third"  onClick={printPDF}>
                <img src={logoPDF} id="img-create-pdf"/> создать отчет
                </button>
                    <a href="#DG_Analysis" className="btn third" >Анализ Дублирования процесса</a>
                </div>
                
            </div>
            
        
    );
}

export default PG_Analysis;

